/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Locationforecast
 * Weather forecast for a specified place
 *
 * OpenAPI spec version: 2.0
 * Contact: weatherapi-adm@met.no
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import type { Configuration } from "./configuration";

const BASE_PATH = "https://api.met.no/weatherapi/locationforecast/2.0".replace(
    /\/+$/,
    ""
);

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    // @ts-ignore
    protected configuration: Configuration;

    constructor(
        configuration?: Configuration,
        protected basePath: string = BASE_PATH,
        protected fetch: FetchAPI = isomorphicFetch
    ) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    // @ts-ignore
    name: "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface Forecast
 */
export interface Forecast {
    /**
     *
     * @type {ForecastMeta}
     * @memberof Forecast
     */
    meta: ForecastMeta;
    /**
     *
     * @type {Array<ForecastTimeStep>}
     * @memberof Forecast
     */
    timeseries: Array<ForecastTimeStep>;
}
/**
 *
 * @export
 * @interface ForecastMeta
 */
export interface ForecastMeta {
    /**
     *
     * @type {ForecastUnits}
     * @memberof ForecastMeta
     */
    units: ForecastUnits;
    /**
     * Update time for this forecast
     * @type {string}
     * @memberof ForecastMeta
     */
    updatedAt: string;
}
/**
 * Summary of weather conditions.
 * @export
 * @interface ForecastSummary
 */
export interface ForecastSummary {
    /**
     *
     * @type {WeatherSymbol}
     * @memberof ForecastSummary
     */
    symbolCode: WeatherSymbol;
}
/**
 * Weather parameters valid for a specific point in time.
 * @export
 * @interface ForecastTimeInstant
 */
export interface ForecastTimeInstant {
    /**
     * Air pressure at sea level
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    air_pressure_at_sea_level?: number;
    /**
     * Air temperature
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    air_temperature?: number;
    /**
     * Amount of sky covered by clouds.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    cloud_area_fraction?: number;
    /**
     * Amount of sky covered by clouds at high elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    cloud_area_fraction_high?: number;
    /**
     * Amount of sky covered by clouds at low elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    cloud_area_fraction_low?: number;
    /**
     * Amount of sky covered by clouds at medium elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    cloud_area_fraction_medium?: number;
    /**
     * Dew point temperature at sea level
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    dew_point_temperature?: number;
    /**
     * Amount of area covered by fog.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    fog_area_fraction?: number;
    /**
     * Amount of humidity in the air.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    relative_humidity?: number;
    /**
     * The directon which moves towards
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    wind_from_direction?: number;
    /**
     * Speed of wind
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    wind_speed?: number;
    /**
     * Speed of wind gust
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    wind_speed_of_gust?: number;
}
/**
 * Weather parameters valid for a specified time period.
 * @export
 * @interface ForecastTimePeriod
 */
export interface ForecastTimePeriod {
    /**
     * Maximum air temperature in period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    air_temperature_max?: number;
    /**
     * Minimum air temperature in period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    air_temperature_min?: number;
    /**
     * Best estimate for amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    precipitation_amount?: number;
    /**
     * Maximum amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    precipitation_amount_max?: number;
    /**
     * Minimum amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    precipitation_amount_min?: number;
    /**
     * Probability of any precipitation coming for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    probability_of_precipitation?: number;
    /**
     * Probability of any thunder coming for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    probability_of_thunder?: number;
    /**
     * Maximum ultraviolet index if sky is clear
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    ultraviolet_index_clear_sky_max?: number;
}
/**
 *
 * @export
 * @interface ForecastTimeStep
 */
export interface ForecastTimeStep {
    /**
     *
     * @type {ForecastTimeStepData}
     * @memberof ForecastTimeStep
     */
    data: ForecastTimeStepData;
    /**
     * The time these forecast values are valid for. Timestamp in format YYYY-MM-DDThh:mm:ssZ (ISO 8601)
     * @type {string}
     * @memberof ForecastTimeStep
     */
    time: string;
}
/**
 * Forecast for a specific time
 * @export
 * @interface ForecastTimeStepData
 */
export interface ForecastTimeStepData {
    /**
     *
     * @type {ForecastTimeStepDataInstant}
     * @memberof ForecastTimeStepData
     */
    instant: ForecastTimeStepDataInstant;
    /**
     *
     * @type {ForecastTimeStepDataNext12Hours}
     * @memberof ForecastTimeStepData
     */
    next_12_hours?: ForecastTimeStepDataNext12Hours;
    /**
     *
     * @type {ForecastTimeStepDataNext1Hours}
     * @memberof ForecastTimeStepData
     */
    next_1_hours?: ForecastTimeStepDataNext1Hours;
    /**
     *
     * @type {ForecastTimeStepDataNext6Hours}
     * @memberof ForecastTimeStepData
     */
    next_6_hours?: ForecastTimeStepDataNext6Hours;
}
/**
 * Parameters which applies to this exact point in time
 * @export
 * @interface ForecastTimeStepDataInstant
 */
export interface ForecastTimeStepDataInstant {
    /**
     *
     * @type {ForecastTimeInstant}
     * @memberof ForecastTimeStepDataInstant
     */
    details?: ForecastTimeInstant;
}
/**
 * Parameters with validity times over twelve hours. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext12Hours
 */
export interface ForecastTimeStepDataNext12Hours {
    /**
     *
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext12Hours
     */
    details: ForecastTimePeriod;
    /**
     *
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext12Hours
     */
    summary: ForecastSummary;
}
/**
 * Parameters with validity times over one hour. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext1Hours
 */
export interface ForecastTimeStepDataNext1Hours {
    /**
     *
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext1Hours
     */
    details: ForecastTimePeriod;
    /**
     *
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext1Hours
     */
    summary: ForecastSummary;
}
/**
 * Parameters with validity times over six hours. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext6Hours
 */
export interface ForecastTimeStepDataNext6Hours {
    /**
     *
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext6Hours
     */
    details: ForecastTimePeriod;
    /**
     *
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext6Hours
     */
    summary: ForecastSummary;
}
/**
 *
 * @export
 * @interface ForecastUnits
 */
export interface ForecastUnits {
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    air_pressure_at_sea_level?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    air_temperature?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    air_temperature_max?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    air_temperature_min?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    cloud_area_fraction?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    cloud_area_fraction_high?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    cloud_area_fraction_low?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    cloud_area_fraction_medium?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    dew_point_temperature?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    fog_area_fraction?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    precipitation_amount?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    precipitation_amount_max?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    precipitation_amount_min?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    probability_of_precipitation?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    probability_of_thunder?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    relative_humidity?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    ultraviolet_index_clear_sky_max?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    wind_from_direction?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    wind_speed?: string;
    /**
     *
     * @type {string}
     * @memberof ForecastUnits
     */
    wind_speed_of_gust?: string;
}
/**
 *
 * @export
 * @interface METJSONForecast
 */
export interface METJSONForecast {
    /**
     *
     * @type {PointGeometry}
     * @memberof METJSONForecast
     */
    geometry: PointGeometry;
    /**
     *
     * @type {Forecast}
     * @memberof METJSONForecast
     */
    properties: Forecast;
    /**
     *
     * @type {string}
     * @memberof METJSONForecast
     */
    type: METJSONForecast.TypeEnum;
}

/**
 * @export
 * @namespace METJSONForecast
 */
export namespace METJSONForecast {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Feature = <any>"Feature",
    }
}
/**
 *
 * @export
 * @interface PointGeometry
 */
export interface PointGeometry {
    /**
     * [longitude, latitude, altitude]. All numbers in decimal.
     * @type {Array<number>}
     * @memberof PointGeometry
     */
    coordinates: Array<number>;
    /**
     *
     * @type {string}
     * @memberof PointGeometry
     */
    type: PointGeometry.TypeEnum;
}

/**
 * @export
 * @namespace PointGeometry
 */
export namespace PointGeometry {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Point = <any>"Point",
    }
}
/**
 * A identifier that sums up the weather condition for this time period. May be used with https://api.met.no/weatherapi/weathericon/2.0/.
 * @export
 * @enum {string}
 */
export enum WeatherSymbol {
    ClearskyDay = <any>"clearsky_day",
    ClearskyNight = <any>"clearsky_night",
    ClearskyPolartwilight = <any>"clearsky_polartwilight",
    FairDay = <any>"fair_day",
    FairNight = <any>"fair_night",
    FairPolartwilight = <any>"fair_polartwilight",
    LightssnowshowersandthunderDay = <any>"lightssnowshowersandthunder_day",
    LightssnowshowersandthunderNight = <any>"lightssnowshowersandthunder_night",
    LightssnowshowersandthunderPolartwilight = <any>(
        "lightssnowshowersandthunder_polartwilight"
    ),
    LightsnowshowersDay = <any>"lightsnowshowers_day",
    LightsnowshowersNight = <any>"lightsnowshowers_night",
    LightsnowshowersPolartwilight = <any>"lightsnowshowers_polartwilight",
    Heavyrainandthunder = <any>"heavyrainandthunder",
    Heavysnowandthunder = <any>"heavysnowandthunder",
    Rainandthunder = <any>"rainandthunder",
    HeavysleetshowersandthunderDay = <any>"heavysleetshowersandthunder_day",
    HeavysleetshowersandthunderNight = <any>"heavysleetshowersandthunder_night",
    HeavysleetshowersandthunderPolartwilight = <any>(
        "heavysleetshowersandthunder_polartwilight"
    ),
    Heavysnow = <any>"heavysnow",
    HeavyrainshowersDay = <any>"heavyrainshowers_day",
    HeavyrainshowersNight = <any>"heavyrainshowers_night",
    HeavyrainshowersPolartwilight = <any>"heavyrainshowers_polartwilight",
    Lightsleet = <any>"lightsleet",
    Heavyrain = <any>"heavyrain",
    LightrainshowersDay = <any>"lightrainshowers_day",
    LightrainshowersNight = <any>"lightrainshowers_night",
    LightrainshowersPolartwilight = <any>"lightrainshowers_polartwilight",
    HeavysleetshowersDay = <any>"heavysleetshowers_day",
    HeavysleetshowersNight = <any>"heavysleetshowers_night",
    HeavysleetshowersPolartwilight = <any>"heavysleetshowers_polartwilight",
    LightsleetshowersDay = <any>"lightsleetshowers_day",
    LightsleetshowersNight = <any>"lightsleetshowers_night",
    LightsleetshowersPolartwilight = <any>"lightsleetshowers_polartwilight",
    Snow = <any>"snow",
    HeavyrainshowersandthunderDay = <any>"heavyrainshowersandthunder_day",
    HeavyrainshowersandthunderNight = <any>"heavyrainshowersandthunder_night",
    HeavyrainshowersandthunderPolartwilight = <any>(
        "heavyrainshowersandthunder_polartwilight"
    ),
    SnowshowersDay = <any>"snowshowers_day",
    SnowshowersNight = <any>"snowshowers_night",
    SnowshowersPolartwilight = <any>"snowshowers_polartwilight",
    Fog = <any>"fog",
    SnowshowersandthunderDay = <any>"snowshowersandthunder_day",
    SnowshowersandthunderNight = <any>"snowshowersandthunder_night",
    SnowshowersandthunderPolartwilight = <any>(
        "snowshowersandthunder_polartwilight"
    ),
    Lightsnowandthunder = <any>"lightsnowandthunder",
    Heavysleetandthunder = <any>"heavysleetandthunder",
    Lightrain = <any>"lightrain",
    RainshowersandthunderDay = <any>"rainshowersandthunder_day",
    RainshowersandthunderNight = <any>"rainshowersandthunder_night",
    RainshowersandthunderPolartwilight = <any>(
        "rainshowersandthunder_polartwilight"
    ),
    Rain = <any>"rain",
    Lightsnow = <any>"lightsnow",
    LightrainshowersandthunderDay = <any>"lightrainshowersandthunder_day",
    LightrainshowersandthunderNight = <any>"lightrainshowersandthunder_night",
    LightrainshowersandthunderPolartwilight = <any>(
        "lightrainshowersandthunder_polartwilight"
    ),
    Heavysleet = <any>"heavysleet",
    Sleetandthunder = <any>"sleetandthunder",
    Lightrainandthunder = <any>"lightrainandthunder",
    Sleet = <any>"sleet",
    LightssleetshowersandthunderDay = <any>"lightssleetshowersandthunder_day",
    LightssleetshowersandthunderNight = <any>"lightssleetshowersandthunder_night",
    LightssleetshowersandthunderPolartwilight = <any>(
        "lightssleetshowersandthunder_polartwilight"
    ),
    Lightsleetandthunder = <any>"lightsleetandthunder",
    PartlycloudyDay = <any>"partlycloudy_day",
    PartlycloudyNight = <any>"partlycloudy_night",
    PartlycloudyPolartwilight = <any>"partlycloudy_polartwilight",
    SleetshowersandthunderDay = <any>"sleetshowersandthunder_day",
    SleetshowersandthunderNight = <any>"sleetshowersandthunder_night",
    SleetshowersandthunderPolartwilight = <any>(
        "sleetshowersandthunder_polartwilight"
    ),
    RainshowersDay = <any>"rainshowers_day",
    RainshowersNight = <any>"rainshowers_night",
    RainshowersPolartwilight = <any>"rainshowers_polartwilight",
    Snowandthunder = <any>"snowandthunder",
    SleetshowersDay = <any>"sleetshowers_day",
    SleetshowersNight = <any>"sleetshowers_night",
    SleetshowersPolartwilight = <any>"sleetshowers_polartwilight",
    Cloudy = <any>"cloudy",
    HeavysnowshowersandthunderDay = <any>"heavysnowshowersandthunder_day",
    HeavysnowshowersandthunderNight = <any>"heavysnowshowersandthunder_night",
    HeavysnowshowersandthunderPolartwilight = <any>(
        "heavysnowshowersandthunder_polartwilight"
    ),
    HeavysnowshowersDay = <any>"heavysnowshowers_day",
    HeavysnowshowersNight = <any>"heavysnowshowers_night",
    HeavysnowshowersPolartwilight = <any>"heavysnowshowers_polartwilight",
}
/**
 * DataApi - fetch parameter creator
 * @export
 */
export const DataApiFetchParamCreator = function (
    configuration?: Configuration
) {
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'lat' is not null or undefined
            if (lat === null || lat === undefined) {
                throw new RequiredError(
                    "lat",
                    "Required parameter lat was null or undefined when calling classicFormatGet."
                );
            }
            // verify required parameter 'lon' is not null or undefined
            if (lon === null || lon === undefined) {
                throw new RequiredError(
                    "lon",
                    "Required parameter lon was null or undefined when calling classicFormatGet."
                );
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError(
                    "format",
                    "Required parameter format was null or undefined when calling classicFormatGet."
                );
            }
            const localVarPath = `/classic.{format}`.replace(
                `{${"format"}}`,
                encodeURIComponent(String(format))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter["altitude"] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter["lat"] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter["lon"] = lon;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet(
            lat: number,
            lon: number,
            altitude?: number,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'lat' is not null or undefined
            if (lat === null || lat === undefined) {
                throw new RequiredError(
                    "lat",
                    "Required parameter lat was null or undefined when calling classicGet."
                );
            }
            // verify required parameter 'lon' is not null or undefined
            if (lon === null || lon === undefined) {
                throw new RequiredError(
                    "lon",
                    "Required parameter lon was null or undefined when calling classicGet."
                );
            }
            const localVarPath = `/classic`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter["altitude"] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter["lat"] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter["lon"] = lon;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'lat' is not null or undefined
            if (lat === null || lat === undefined) {
                throw new RequiredError(
                    "lat",
                    "Required parameter lat was null or undefined when calling compactFormatGet."
                );
            }
            // verify required parameter 'lon' is not null or undefined
            if (lon === null || lon === undefined) {
                throw new RequiredError(
                    "lon",
                    "Required parameter lon was null or undefined when calling compactFormatGet."
                );
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError(
                    "format",
                    "Required parameter format was null or undefined when calling compactFormatGet."
                );
            }
            const localVarPath = `/compact.{format}`.replace(
                `{${"format"}}`,
                encodeURIComponent(String(format))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter["altitude"] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter["lat"] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter["lon"] = lon;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet(
            lat: number,
            lon: number,
            altitude?: number,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'lat' is not null or undefined
            if (lat === null || lat === undefined) {
                throw new RequiredError(
                    "lat",
                    "Required parameter lat was null or undefined when calling compactGet."
                );
            }
            // verify required parameter 'lon' is not null or undefined
            if (lon === null || lon === undefined) {
                throw new RequiredError(
                    "lon",
                    "Required parameter lon was null or undefined when calling compactGet."
                );
            }
            const localVarPath = `/compact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter["altitude"] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter["lat"] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter["lon"] = lon;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'lat' is not null or undefined
            if (lat === null || lat === undefined) {
                throw new RequiredError(
                    "lat",
                    "Required parameter lat was null or undefined when calling completeFormatGet."
                );
            }
            // verify required parameter 'lon' is not null or undefined
            if (lon === null || lon === undefined) {
                throw new RequiredError(
                    "lon",
                    "Required parameter lon was null or undefined when calling completeFormatGet."
                );
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError(
                    "format",
                    "Required parameter format was null or undefined when calling completeFormatGet."
                );
            }
            const localVarPath = `/complete.{format}`.replace(
                `{${"format"}}`,
                encodeURIComponent(String(format))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter["altitude"] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter["lat"] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter["lon"] = lon;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet(
            lat: number,
            lon: number,
            altitude?: number,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'lat' is not null or undefined
            if (lat === null || lat === undefined) {
                throw new RequiredError(
                    "lat",
                    "Required parameter lat was null or undefined when calling completeGet."
                );
            }
            // verify required parameter 'lon' is not null or undefined
            if (lon === null || lon === undefined) {
                throw new RequiredError(
                    "lon",
                    "Required parameter lon was null or undefined when calling completeGet."
                );
            }
            const localVarPath = `/complete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter["altitude"] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter["lat"] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter["lon"] = lon;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {string} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet(format: string, options: any = {}): FetchArgs {
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError(
                    "format",
                    "Required parameter format was null or undefined when calling statusFormatGet."
                );
            }
            const localVarPath = `/status.{format}`.replace(
                `{${"format"}}`,
                encodeURIComponent(String(format))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options: any = {}): FetchArgs {
            const localVarPath = `/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DataApiFetchParamCreator(
                configuration
            ).classicFormatGet(lat, lon, format, altitude, options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet(
            lat: number,
            lon: number,
            altitude?: number,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DataApiFetchParamCreator(
                configuration
            ).classicGet(lat, lon, altitude, options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<METJSONForecast> {
            const localVarFetchArgs = DataApiFetchParamCreator(
                configuration
            ).compactFormatGet(lat, lon, format, altitude, options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet(
            lat: number,
            lon: number,
            altitude?: number,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<METJSONForecast> {
            const localVarFetchArgs = DataApiFetchParamCreator(
                configuration
            ).compactGet(lat, lon, altitude, options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<METJSONForecast> {
            const localVarFetchArgs = DataApiFetchParamCreator(
                configuration
            ).completeFormatGet(lat, lon, format, altitude, options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet(
            lat: number,
            lon: number,
            altitude?: number,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<METJSONForecast> {
            const localVarFetchArgs = DataApiFetchParamCreator(
                configuration
            ).completeGet(lat, lon, altitude, options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {string} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet(
            format: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = DataApiFetchParamCreator(
                configuration
            ).statusFormatGet(format, options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs =
                DataApiFetchParamCreator(configuration).statusGet(options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options?: any
        ) {
            return DataApiFp(configuration).classicFormatGet(
                lat,
                lon,
                format,
                altitude,
                options
            )(fetch, basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet(lat: number, lon: number, altitude?: number, options?: any) {
            return DataApiFp(configuration).classicGet(
                lat,
                lon,
                altitude,
                options
            )(fetch, basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options?: any
        ) {
            return DataApiFp(configuration).compactFormatGet(
                lat,
                lon,
                format,
                altitude,
                options
            )(fetch, basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet(lat: number, lon: number, altitude?: number, options?: any) {
            return DataApiFp(configuration).compactGet(
                lat,
                lon,
                altitude,
                options
            )(fetch, basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {string} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet(
            lat: number,
            lon: number,
            format: string,
            altitude?: number,
            options?: any
        ) {
            return DataApiFp(configuration).completeFormatGet(
                lat,
                lon,
                format,
                altitude,
                options
            )(fetch, basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet(lat: number, lon: number, altitude?: number, options?: any) {
            return DataApiFp(configuration).completeGet(
                lat,
                lon,
                altitude,
                options
            )(fetch, basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {string} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet(format: string, options?: any) {
            return DataApiFp(configuration).statusFormatGet(format, options)(
                fetch,
                basePath
            );
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: any) {
            return DataApiFp(configuration).statusGet(options)(fetch, basePath);
        },
    };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {string} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public classicFormatGet(
        lat: number,
        lon: number,
        format: string,
        altitude?: number,
        options?: any
    ) {
        return DataApiFp(this.configuration).classicFormatGet(
            lat,
            lon,
            format,
            altitude,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public classicGet(
        lat: number,
        lon: number,
        altitude?: number,
        options?: any
    ) {
        return DataApiFp(this.configuration).classicGet(
            lat,
            lon,
            altitude,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {string} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public compactFormatGet(
        lat: number,
        lon: number,
        format: string,
        altitude?: number,
        options?: any
    ) {
        return DataApiFp(this.configuration).compactFormatGet(
            lat,
            lon,
            format,
            altitude,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public compactGet(
        lat: number,
        lon: number,
        altitude?: number,
        options?: any
    ) {
        return DataApiFp(this.configuration).compactGet(
            lat,
            lon,
            altitude,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {string} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public completeFormatGet(
        lat: number,
        lon: number,
        format: string,
        altitude?: number,
        options?: any
    ) {
        return DataApiFp(this.configuration).completeFormatGet(
            lat,
            lon,
            format,
            altitude,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public completeGet(
        lat: number,
        lon: number,
        altitude?: number,
        options?: any
    ) {
        return DataApiFp(this.configuration).completeGet(
            lat,
            lon,
            altitude,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Weather forecast for a specified place
     * @param {string} format format code (file extension)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public statusFormatGet(format: string, options?: any) {
        return DataApiFp(this.configuration).statusFormatGet(format, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Weather forecast for a specified place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public statusGet(options?: any) {
        return DataApiFp(this.configuration).statusGet(options)(
            this.fetch,
            this.basePath
        );
    }
}
/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (
    configuration?: Configuration
) {
    return {
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet(options: any = {}): FetchArgs {
            const localVarPath = `/healthz`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet(options: any = {}): FetchArgs {
            const localVarPath = `/schema`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: "GET" }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs =
                MetadataApiFetchParamCreator(configuration).healthzGet(options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs =
                MetadataApiFetchParamCreator(configuration).schemaGet(options);
            return (
                fetch: FetchAPI = isomorphicFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet(options?: any) {
            return MetadataApiFp(configuration).healthzGet(options)(fetch, basePath);
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet(options?: any) {
            return MetadataApiFp(configuration).schemaGet(options)(fetch, basePath);
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * Check health status for product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public healthzGet(options?: any) {
        return MetadataApiFp(this.configuration).healthzGet(options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Schema for XML data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public schemaGet(options?: any) {
        return MetadataApiFp(this.configuration).schemaGet(options)(
            this.fetch,
            this.basePath
        );
    }
}
